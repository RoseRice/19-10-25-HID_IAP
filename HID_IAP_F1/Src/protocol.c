#include "protocol.h"
#include "usbd_custom_hid_if.h"
#include "iap.h"
#include "gpio.h"

static uint32_t FileSize = 0; // 传输的文件大小
static uint16_t BlkIndex = 0; // 数据块序号
static uint16_t BlkSize = 0; // 块有效数据长度
static uint8_t  BlkBuf[BLK_RCV_BUF_SIZE] = {0}; // 接受数据块缓存
static uint16_t BlkOffset = 0; // 块接收数据末尾位置
static uint32_t FileOffset = 0; // 已接收数据大小

static uint16_t CRC16(uint8_t *buf, uint32_t size);

/*
** 功能：准备开始数据传输
** 输入：
** 输出：
*/
uint8_t FunTransReady(void)
{
  uint8_t err_code = 0;
  uint32_t err_inf = 0;
  FLASH_EraseInitTypeDef erase_init;
  
  BlkOffset = 0;
  FileOffset = 0;

  FileSize = RcvUSB.buf[1] + (RcvUSB.buf[2]<<8) + (RcvUSB.buf[3]<<16) + (RcvUSB.buf[4]<<24);

  HAL_FLASH_Unlock(); // 解锁
  // 清空APP Flash空间
  erase_init.TypeErase = FLASH_TYPEERASE_PAGES;
  //erase_init.Banks = FLASH_BANK_1;
  erase_init.PageAddress = FLASH_APP_ADDR;
  erase_init.NbPages = (512-64)/2;

  if(HAL_OK != HAL_FLASHEx_Erase(&erase_init, &err_inf))  err_code = 1;
  HAL_FLASH_Lock(); // 上锁

  // 设备状态应答
  memset(SndUSB.buf, 0x00, sizeof(SndUSB.buf));
  
  SndUSB.hasData = TRUE_t;
  SndUSB.buf[0] = RcvUSB.buf[0];
  SndUSB.buf[1] = err_code;
  SndUSB.buf[2] = err_inf & 0xFF;
  SndUSB.buf[3] = (err_inf>>8) & 0xFF;
  SndUSB.buf[4] = (err_inf>>16) & 0xFF;
  SndUSB.buf[5] = (err_inf>>24) & 0xFF;
  
  return 0;
}

/*
** 功能：数据传输完成
** 输入：
** 输出：
*/
uint8_t FunTransEnd(void)
{
  uint8_t err_code = 0;
  
  if(1 == RcvUSB.buf[1]) // 启动APP程序
  {
    if(((*(vu32 *)(FLASH_APP_ADDR+4))&0xFF000000)==0x08000000)//判断是否为0X08XXXXXX.
    {	 
      err_code = iapLoadAppCheck(FLASH_APP_ADDR);// 检查FLASH APP代码
    }
    else
    {
      err_code = 2;
    }
  }

  // 设备状态应答
  memset(SndUSB.buf, 0x00, sizeof(SndUSB.buf));
  
  SndUSB.hasData = TRUE_t;
  SndUSB.buf[0] = RcvUSB.buf[0];
  SndUSB.buf[1] = err_code;
  USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, SndUSB.buf, sizeof(SndUSB.buf));
  
  //执行FLASH APP代码
  if(APP_IS_OK == err_code)
  {
    USB_DE_OFF; // 断开USB上拉电阻
    iapLoadApp(FLASH_APP_ADDR);
  }

  return 0;
}

/*
** 功能：启动数据块传输
** 输入：
** 输出：
*/
uint8_t FunBlockStart(void)
{
  BlkOffset = 0;
  
  BlkIndex = RcvUSB.buf[1] + (RcvUSB.buf[2]<<8);
  BlkSize = RcvUSB.buf[3] + (RcvUSB.buf[4]<<8);
  
  // 清空接受缓存
  memset(BlkBuf, 0x00, sizeof(BlkBuf));
  
  // 设备状态应答
  memset(SndUSB.buf, 0x00, sizeof(SndUSB.buf));
  
  SndUSB.hasData = TRUE_t;
  SndUSB.buf[0] = RcvUSB.buf[0];
  SndUSB.buf[1] = 0x00;
  
  return 0;
}

/*
** 功能：数据块传输结束
** 输入：
** 输出：
*/
uint8_t FunBlockFinish(void)
{
  uint8_t err_code = 0;
  
  // 校验后向flash写入数据块
  if((RcvUSB.buf[1]+(RcvUSB.buf[2]<<8)) == CRC16(BlkBuf, BlkOffset))
  {
    if(BlkOffset <= BlkSize)
    {
      if(FileOffset <= FileSize)
      {
        err_code = iapWriteAppBin(FLASH_APP_ADDR+FileOffset, BlkBuf, BlkOffset);
      }
      else
      {
        err_code = 4;
      }
      FileOffset += BlkOffset;
    }
    else
    {
      err_code = 5;
    }
  }
  else
  {
    err_code = 6;
  }
  
  // inote 可考虑回读flash并校验
  
  // 设备状态应答
  memset(SndUSB.buf, 0x00, sizeof(SndUSB.buf));
  
  SndUSB.hasData = TRUE_t;
  SndUSB.buf[0] = RcvUSB.buf[0];
  SndUSB.buf[1] = BlkIndex & 0xFF;
  SndUSB.buf[2] = (BlkIndex>>8) & 0xFF;
  SndUSB.buf[3] = err_code; // 错误码
  
  return 0;
}

/*
** 功能：数据帧传输
** 输入：
** 输出：
*/
uint8_t FunFrameData(void)
{
  if((USBD_CUSTOMHID_OUTREPORT_BUF_SIZE-2) >= RcvUSB.buf[1])
  {
    memcpy(&BlkBuf[BlkOffset], &RcvUSB.buf[2], RcvUSB.buf[1]);
    BlkOffset += RcvUSB.buf[1];
  }
  
  return 0;
}

/*
** 功能：控制命令
** 输入：
** 输出：
*/
uint8_t FunControl(void)
{
  uint8_t err_code = 0;
  
  switch(RcvUSB.buf[1])
  {
    case 0x01: // 获取版本号
      memset(SndUSB.buf, 0x00, sizeof(SndUSB.buf));
      /* 方式1
      for(cnt=0; '\0'!=*(softVersion+cnt); cnt++)
      {
        USB_SendBuf[2+cnt] = *(softVersion+cnt);
      }*/
      memcpy(&SndUSB.buf[2], SOFT_VERSION, sizeof(SOFT_VERSION));
      break;
    default:
      err_code = 0xFF;
      break;
  }
  
  // 设备状态应答
  SndUSB.hasData = TRUE_t;
  SndUSB.buf[0] = RcvUSB.buf[0];
  SndUSB.buf[1] = err_code; // 错误码
  
  return 0;
}

const uint8_t auchCRCHi[] =  // 高位字节的CRC值
{
  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41,  0x01,  0xC0,  0x80, 0x41,
  0x00, 0xC1, 0x81,
  0x40,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00,  0xC1, 0x81,
  0x40, 0x01, 0xC0,
  0x80,  0x41,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00, 0xC1,
  0x81, 0x40, 0x01,
  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41, 0x01,
  0xC0, 0x80, 0x41,
  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81, 0x40,
  0x00, 0xC1, 0x81,
  0x40,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0, 0x80,
  0x41, 0x01, 0xC0,
  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00,  0xC1,  0x81,  0x40,  0x01, 0xC0,
  0x80, 0x41, 0x01,
  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41, 0x00,
  0xC1, 0x81, 0x40,
  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41,  0x01,  0xC0,  0x80, 0x41,
  0x00, 0xC1, 0x81,
  0x40,  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1, 0x81,
  0x40, 0x01, 0xC0,
  0x80,  0x41,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00, 0xC1,
  0x81, 0x40, 0x01,
  0xC0,  0x80,  0x41,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40, 0x01,
  0xC0, 0x80, 0x41,
  0x00,  0xC1,  0x81,  0x40,  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80, 0x41,
  0x00, 0xC1, 0x81,
  0x40,  0x01,  0xC0,  0x80,  0x41,  0x01,  0xC0,  0x80,  0x41,  0x00,  0xC1, 0x81,
  0x40, 0x01, 0xC0,
  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00,  0xC1,  0x81,  0x40,  0x01, 0xC0,
  0x80, 0x41, 0x01,
  0xC0,  0x80,  0x41,  0x00,  0xC1,  0x81,  0x40,  0x00,  0xC1,  0x81,  0x40, 0x01,
  0xC0, 0x80, 0x41,
  0x00,  0xC1,  0x81,  0x40,  0x01,  0xC0,  0x80,  0x41,  0x01,  0xC0,  0x80, 0x41,
  0x00, 0xC1, 0x81,
  0x40
};

const uint8_t auchCRCLo[] = // 低位字节的CRC值
{
  0x00,  0xC0,  0xC1,  0x01,  0xC3,  0x03,  0x02,  0xC2,  0xC6,  0x06,  0x07, 0xC7,
  0x05, 0xC5, 0xC4,
  0x04,  0xCC,  0x0C,  0x0D,  0xCD,  0x0F,  0xCF,  0xCE,  0x0E,  0x0A,  0xCA, 0xCB,
  0x0B, 0xC9, 0x09,
  0x08,  0xC8,  0xD8,  0x18,  0x19,  0xD9,  0x1B,  0xDB,  0xDA,  0x1A,  0x1E, 0xDE,
  0xDF, 0x1F, 0xDD,
  0x1D,  0x1C,  0xDC,  0x14,  0xD4,  0xD5,  0x15,  0xD7,  0x17,  0x16,  0xD6, 0xD2,
  0x12, 0x13, 0xD3,
  0x11,  0xD1,  0xD0,  0x10,  0xF0,  0x30,  0x31,  0xF1,  0x33,  0xF3,  0xF2, 0x32,
  0x36, 0xF6, 0xF7,
  0x37,  0xF5,  0x35,  0x34,  0xF4,  0x3C,  0xFC,  0xFD,  0x3D,  0xFF,  0x3F, 0x3E,
  0xFE, 0xFA, 0x3A,
  0x3B,  0xFB,  0x39,  0xF9,  0xF8,  0x38,  0x28,  0xE8,  0xE9,  0x29,  0xEB, 0x2B,
  0x2A, 0xEA, 0xEE,
  0x2E,  0x2F,  0xEF,  0x2D,  0xED,  0xEC,  0x2C,  0xE4,  0x24,  0x25,  0xE5, 0x27,
  0xE7, 0xE6, 0x26,
  0x22,  0xE2,  0xE3,  0x23,  0xE1,  0x21,  0x20,  0xE0,  0xA0,  0x60,  0x61, 0xA1,
  0x63, 0xA3, 0xA2,
  0x62,  0x66,  0xA6,  0xA7,  0x67,  0xA5,  0x65,  0x64,  0xA4,  0x6C,  0xAC, 0xAD,
  0x6D, 0xAF, 0x6F,
  0x6E,  0xAE,  0xAA,  0x6A,  0x6B,  0xAB,  0x69,  0xA9,  0xA8,  0x68,  0x78, 0xB8,
  0xB9, 0x79, 0xBB,
  0x7B,  0x7A,  0xBA,  0xBE,  0x7E,  0x7F,  0xBF,  0x7D,  0xBD,  0xBC,  0x7C, 0xB4,
  0x74, 0x75, 0xB5,
  0x77,  0xB7,  0xB6,  0x76,  0x72,  0xB2,  0xB3,  0x73,  0xB1,  0x71,  0x70, 0xB0,
  0x50, 0x90, 0x91,
  0x51,  0x93,  0x53,  0x52,  0x92,  0x96,  0x56,  0x57,  0x97,  0x55,  0x95, 0x94,
  0x54, 0x9C, 0x5C,
  0x5D,  0x9D,  0x5F,  0x9F,  0x9E,  0x5E,  0x5A,  0x9A,  0x9B,  0x5B,  0x99, 0x59,
  0x58, 0x98, 0x88,
  0x48,  0x49,  0x89,  0x4B,  0x8B,  0x8A,  0x4A,  0x4E,  0x8E,  0x8F,  0x4F, 0x8D,
  0x4D, 0x4C, 0x8C,
  0x44,  0x84,  0x85,  0x45,  0x87,  0x47,  0x46,  0x86 ,  0x82,  0x42,  0x43, 0x83,
  0x41, 0x81, 0x80,
  0x40
};

/*
** 功能：CRC-16校验码计算
** 输入：*buf[数据buffer]  size[buffer长度]
** 输出：计算得出的校验码
*/
static uint16_t CRC16(uint8_t *buf, uint32_t size)
{
  uint32_t i = 0;
  uint8_t uchCRCHi = 0xFF;
  uint8_t uchCRCLo = 0xFF;
  uint8_t uIndex = 0x00;

  for(i = 0; i < size; i++)
  {
      uIndex = uchCRCLo ^ (uint8_t)buf[i];
      uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex];
      uchCRCHi = auchCRCLo[uIndex];
  }

  return (uchCRCHi << 8 | uchCRCLo);
}
